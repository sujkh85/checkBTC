import 'dotenv/config';
import axios from 'axios';
import TelegramBot from 'node-telegram-bot-api';
import { SMA, RSI, MACD, BollingerBands, Stochastic, OBV, ADX, EMA } from 'technicalindicators';
import { analyzeHarmonicPattern } from './src/indicators/harmonic.js';
import { analyzeIchimoku } from './src/indicators/ichimoku.js';
import { analyzeElliottWave } from './src/indicators/elliott.js';
import { analyzeSupportResistance } from './src/indicators/supportResistance.js';
import { analyzeOverallTrend } from './src/indicators/trendAnalysis.js';
import { 
    TIME_FRAMES, 
    MA_PERIODS, 
    TECHNICAL_SETTINGS, 
    API_SETTINGS 
} from './src/settings.js';

// ÌÖîÎ†àÍ∑∏Îû® Î¥á ÏÑ§Ï†ï
const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: false });

// API ÏÑ§Ï†ï
const { OKX_API_URL, SYMBOL } = API_SETTINGS;

// Ïù¥Ï†Ñ Ï∂îÏÑ∏ Ï†êÏàòÎ•º Ï†ÄÏû•Ìï† Î≥ÄÏàò
let previousWeightedTrends = null;

// ÏòàÏ∏° Í∏∞Î°ùÏùÑ Ï†ÄÏû•Ìï† Î∞∞Ïó¥
let predictionHistory = [];

// ÎàÑÏ†Å Ï†ïÌôïÎèÑ ÌÜµÍ≥Ñ
let accuracyStats = {
    total: 0,
    correct: 0,
    incorrect: 0,
    accuracy: 0
};

// Ï†ÑÏó≠ Î≥ÄÏàòÎ°ú ÏòàÏ∏° Ï†ïÎ≥¥ Ï†ÄÏû•
let currentPrediction = null;

// Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò
async function getPriceData(timeFrame) {
    try {
        console.log(`OKXÏóêÏÑú ${SYMBOL} ${timeFrame.name} Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠ Ï§ë...`);
        const response = await axios.get(
            `${OKX_API_URL}/market/candles?instId=${SYMBOL}&bar=${timeFrame.interval}&limit=${timeFrame.limit}`
        );
        const prices = response.data.data.map(candle => ({
            timestamp: parseInt(candle[0]),
            open: parseFloat(candle[1]),
            high: parseFloat(candle[2]),
            low: parseFloat(candle[3]),
            close: parseFloat(candle[4]),
            volume: parseFloat(candle[5])
        }));
        console.log(`OKXÏóêÏÑú ${SYMBOL} ${timeFrame.name} Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÏôÑÎ£å (${prices.length}Í∞ú Ï∫îÎì§)`);
        return prices;
    } catch (error) {
        console.error(`${timeFrame.name} Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:`, error.message);
        return null;
    }
}

// Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ Ìï®Ïàò
function calculateIndicators(prices) {
    const closes = prices.map(p => p.close);
    const highs = prices.map(p => p.high);
    const lows = prices.map(p => p.low);
    const volumes = prices.map(p => p.volume);
    
    // Ïù¥ÌèâÏÑ† Í≥ÑÏÇ∞
    const movingAverages = {};
    
    // Îã®Í∏∞ Ïù¥ÌèâÏÑ†
    MA_PERIODS.short.forEach(period => {
        movingAverages[`ma${period}`] = calculateMA(closes, period);
    });
    
    // Ï§ëÍ∏∞ Ïù¥ÌèâÏÑ†
    MA_PERIODS.medium.forEach(period => {
        if (closes.length >= period) {
            movingAverages[`ma${period}`] = calculateMA(closes, period);
        }
    });
    
    // Ïû•Í∏∞ Ïù¥ÌèâÏÑ†
    MA_PERIODS.long.forEach(period => {
        if (closes.length >= period) {
            movingAverages[`ma${period}`] = calculateMA(closes, period);
        }
    });
    
    // RSI Í≥ÑÏÇ∞
    const rsi = RSI.calculate({
        values: closes,
        period: TECHNICAL_SETTINGS.rsi.period
    });
    
    // MACD Í≥ÑÏÇ∞
    const macd = MACD.calculate({
        values: closes,
        ...TECHNICAL_SETTINGS.macd
    });
    
    // Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Í≥ÑÏÇ∞
    const bb = BollingerBands.calculate({
        values: closes,
        ...TECHNICAL_SETTINGS.bb
    });

    // Ïä§ÌÜ†Ï∫êÏä§Ìã± Í≥ÑÏÇ∞
    const stoch = Stochastic.calculate({
        high: highs,
        low: lows,
        close: closes,
        ...TECHNICAL_SETTINGS.stoch
    });

    // OBV Í≥ÑÏÇ∞
    const obv = OBV.calculate({
        close: closes,
        volume: volumes
    });

    // ADX Í≥ÑÏÇ∞
    const adx = ADX.calculate({
        high: highs,
        low: lows,
        close: closes,
        period: TECHNICAL_SETTINGS.adx.period
    });

    // Ïù¥ÌèâÏÑ† ÌÅ¨Î°úÏä§ Í≥ÑÏÇ∞
    const fastMA = SMA.calculate({
        values: closes,
        period: TECHNICAL_SETTINGS.ma.fastPeriod
    });
    const slowMA = SMA.calculate({
        values: closes,
        period: TECHNICAL_SETTINGS.ma.slowPeriod
    });
    
    return {
        rsi: rsi[rsi.length - 1],
        macd: macd[macd.length - 1],
        bb: bb[bb.length - 1],
        stoch: stoch[stoch.length - 1],
        obv: obv[obv.length - 1],
        adx: adx[adx.length - 1],
        maCross: {
            fast: fastMA[fastMA.length - 1],
            slow: slowMA[slowMA.length - 1]
        },
        movingAverages
    };
}

// Ïù¥ÌèâÏÑ† Í≥ÑÏÇ∞ Ìï®Ïàò
function calculateMA(data, period) {
    const result = [];
    for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
            result.push(null);
            continue;
        }
        const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
        result.push(sum / period);
    }
    return result;
}

// ÏòàÏ∏° Ï†ïÌôïÎèÑ Î∂ÑÏÑù Ìï®Ïàò
async function analyzePredictionAccuracy() {
    try {
        console.log('ÏòàÏ∏° Ï†ïÌôïÎèÑ Î∂ÑÏÑù ÏãúÏûë...');
        // 30Î∂ÑÎ¥â Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        const thirtyMinData = await getPriceData({ name: '30Î∂ÑÎ¥â', interval: '30m', limit: 3 });
        if (!thirtyMinData || thirtyMinData.length < 3) {
            console.log('Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±ÌïòÏó¨ Î∂ÑÏÑùÏùÑ Í±¥ÎÑàÎúÅÎãàÎã§.');
            return;
        }

        const currentPrice = thirtyMinData[thirtyMinData.length - 1].close;
        const ninetyMinutesAgoPrice = thirtyMinData[0].close;
        
        // Í∞ÄÍ≤© Î≥ÄÎèôÎ•† Í≥ÑÏÇ∞
        const priceChange = ((currentPrice - ninetyMinutesAgoPrice) / ninetyMinutesAgoPrice) * 100;
        
        // Ïã§Ï†ú Ï∂îÏÑ∏ ÌåêÎã® (30Î∂ÑÎ¥â Í∏∞Ï§ÄÏúºÎ°ú ÏûÑÍ≥ÑÍ∞í Ï°∞Ï†ï)
        let actualTrend;
        if (priceChange > 0.5) {
            actualTrend = 'ÏÉÅÏäπ';
        } else if (priceChange < -0.5) {
            actualTrend = 'ÌïòÎùΩ';
        } else {
            actualTrend = 'Ìö°Î≥¥';
        }

        // ÏòàÏ∏° Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ Ï†ïÌôïÎèÑ Î∂ÑÏÑù
        if (currentPrediction) {
            const isCorrect = currentPrediction.predictedTrend === actualTrend;
            
            // ÎàÑÏ†Å ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            accuracyStats.total++;
            if (isCorrect) {
                accuracyStats.correct++;
            } else {
                accuracyStats.incorrect++;
            }
            accuracyStats.accuracy = (accuracyStats.correct / accuracyStats.total * 100).toFixed(2);
            
            // Ï†ïÌôïÎèÑ Î©îÏãúÏßÄ ÏÉùÏÑ±
            let accuracyMessage = `\n*ÏòàÏ∏° Ï†ïÌôïÎèÑ Î∂ÑÏÑù (30Î∂ÑÎ¥â Í∏∞Ï§Ä)*\n`;
            accuracyMessage += `‚Ä¢ ÏòàÏ∏°: ${currentPrediction.predictedTrend}\n`;
            accuracyMessage += `‚Ä¢ Ïã§Ï†ú: ${actualTrend}\n`;
            accuracyMessage += `‚Ä¢ Í∞ÄÍ≤© Î≥ÄÎèô: ${priceChange.toFixed(2)}%\n`;
            accuracyMessage += `‚Ä¢ Í≤∞Í≥º: ${isCorrect ? '‚úÖ Ï†ïÌôï' : '‚ùå Î∂ÄÏ†ïÌôï'}\n\n`;
            
            // ÎàÑÏ†Å ÌÜµÍ≥Ñ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
            accuracyMessage += `*ÎàÑÏ†Å ÏòàÏ∏° ÌÜµÍ≥Ñ*\n`;
            accuracyMessage += `‚Ä¢ Ï¥ù ÏòàÏ∏°: ${accuracyStats.total}Ìöå\n`;
            accuracyMessage += `‚Ä¢ Ï†ïÌôï: ${accuracyStats.correct}Ìöå\n`;
            accuracyMessage += `‚Ä¢ Î∂ÄÏ†ïÌôï: ${accuracyStats.incorrect}Ìöå\n`;
            accuracyMessage += `‚Ä¢ Ï†ïÌôïÎèÑ: ${accuracyStats.accuracy}%\n`;
            
            // ÌÖîÎ†àÍ∑∏Îû®ÏúºÎ°ú Ï†ïÌôïÎèÑ Î©îÏãúÏßÄ Ï†ÑÏÜ°
            await bot.sendMessage(process.env.TELEGRAM_CHAT_ID, accuracyMessage, { parse_mode: 'Markdown' });
            
            // ÌòÑÏû¨ ÏòàÏ∏° Ï†ïÎ≥¥ Ï¥àÍ∏∞Ìôî
            currentPrediction = null;
        }

    } catch (error) {
        console.error('ÏòàÏ∏° Ï†ïÌôïÎèÑ Î∂ÑÏÑù Ï§ë ÏóêÎü¨ Î∞úÏÉù:', error.message);
    }
}

// Í∞ÄÍ≤© Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Í≥† ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ¥Îäî Ìï®Ïàò
async function checkPriceAndNotify() {
    try {
        const timeFrameTrends = {};
        let message = `*${SYMBOL} Ï∂îÏÑ∏ Î∂ÑÏÑù*(Ïä§Ïúô Ï†ÑÎûµ)\n\n`;
        let currentPrice = null;

        // Í∞Å ÏãúÍ∞ÑÎåÄÎ≥ÑÎ°ú Î∂ÑÏÑù
        for (const timeFrame of TIME_FRAMES) {
            const prices = await getPriceData(timeFrame);
            if (!prices || prices.length === 0) continue;

            // ÌòÑÏû¨ Í∞ÄÍ≤© Ï†ÄÏû• (30Î∂ÑÎ¥â Í∏∞Ï§Ä)
            if (timeFrame.interval === '30m') {
                currentPrice = prices[prices.length - 1].close;
            }

            const indicators = calculateIndicators(prices);
            
            // ÌïòÎ™®Îãâ Ìå®ÌÑ¥ Î∂ÑÏÑù
            const harmonic = analyzeHarmonicPattern(prices);
            
            // ÏùºÎ™©Íµ¨Î¶ÑÌëú Î∂ÑÏÑù
            const ichimoku = analyzeIchimoku(prices);
            
            // ÏóòÎ¶¨Ïñ¥Ìä∏ ÌååÎèô Î∂ÑÏÑù
            const elliott = analyzeElliottWave(prices);
            
            // ÏßÄÏßÄ/Ï†ÄÌï≠ Î∂ÑÏÑù
            const supportResistance = analyzeSupportResistance(prices);
            
            // Ï¢ÖÌï© Ï∂îÏÑ∏ Î∂ÑÏÑù
            const trend = analyzeOverallTrend(
                indicators,
                harmonic,
                ichimoku,
                elliott,
                supportResistance,
                prices,
                timeFrame.interval
            );

            // Ï∂îÏÑ∏ ÏïÑÏù¥ÏΩò ÏÑ†ÌÉù
            const trendIcon = trend.trend === 'ÏÉÅÏäπ' ? 'üìà' : trend.trend === 'ÌïòÎùΩ' ? 'üìâ' : '‚öñÔ∏è';
            
            // ÏãúÍ∞ÑÎåÄÎ≥Ñ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
            message += `*--${timeFrame.name} ${trendIcon} (Í∞ÄÏ§ëÏπò: ${timeFrame.weight})*\n`;
            message += `‚Ä¢ Ï¢ÖÌï© Ï∂îÏÑ∏: *${trend.trend}* (Í∞ïÎèÑ: ${trend.strength}%)\n\n`;
            
            // ÏßÄÌëúÎ≥Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            message += `*üîç ÏßÄÌëúÎ≥Ñ Î∂ÑÏÑù*\n`;
            message += `‚Ä¢ RSI: ${indicators.rsi.toFixed(2)} (${indicators.rsi > 70 ? 'Í≥ºÎß§Ïàò' : indicators.rsi < 30 ? 'Í≥ºÎß§ÎèÑ' : 'Ï§ëÎ¶Ω'})\n`;
            
            // Ïù¥ÌèâÏÑ† ÌÅ¨Î°úÏä§ Î∂ÑÏÑù
            const maDiff = Math.abs(indicators.maCross.fast - indicators.maCross.slow);
            const maDiffPercent = (maDiff / indicators.maCross.slow * 100).toFixed(2);
            if (maDiffPercent < 0.5) {
                message += `‚Ä¢ Ïù¥ÌèâÏÑ† ÌÅ¨Î°úÏä§: *Í≥®Îì†ÌÅ¨Î°úÏä§ ÏûÑÎ∞ï* (Ï∞®Ïù¥: ${maDiffPercent}%)\n`;
            } else if (maDiffPercent < 1.0) {
                message += `‚Ä¢ Ïù¥ÌèâÏÑ† ÌÅ¨Î°úÏä§: *Îç∞ÎìúÌÅ¨Î°úÏä§ ÏûÑÎ∞ï* (Ï∞®Ïù¥: ${maDiffPercent}%)\n`;
            }

            // Ìå®ÌÑ¥ Î∂ÑÏÑù Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            message += `*üîç Ìå®ÌÑ¥ Î∂ÑÏÑù*\n`;
            const harmonicPatterns = Object.values(harmonic).filter(v => v && v.indexOf('ÏóÜÏùå') === -1);
            if (harmonicPatterns.length > 0) {
                message += `‚Ä¢ ÌïòÎ™®Îãâ Ìå®ÌÑ¥: ${harmonicPatterns.join(', ')}\n`;
            }
            console.log(harmonicPatterns);
            message += `‚Ä¢ ÏùºÎ™©Íµ¨Î¶ÑÌëú: ${ichimoku.signals.join(', ') || 'ÏóÜÏùå'}\n`;
            message += `‚Ä¢ ÏóòÎ¶¨Ïñ¥Ìä∏ ÌååÎèô: ${elliott.pattern || 'ÏóÜÏùå'}\n`;
            if (elliott.currentWave) {
                message += `  - ÌòÑÏû¨ Îã®Í≥Ñ: ${elliott.currentWave.currentPhase}\n`;
                message += `  - ÏòàÏÉÅ Îã§Ïùå ÌååÎèô: *${elliott.currentWave.nextExpectedWave}*\n\n`;
            }

            // ÏãúÍ∞ÑÎåÄÎ≥Ñ Ï∂îÏÑ∏ Ï†ÄÏû•
            timeFrameTrends[timeFrame.interval] = {
                trend: trend.trend,
                strength: trend.strength,
                weight: timeFrame.weight
            };
        }

        // Í∞ÄÏ§ëÏπòÎ•º Í≥†Î†§Ìïú Ï¢ÖÌï© Ï∂îÏÑ∏ ÌåêÎã®
        const weightedTrends = {
            'ÏÉÅÏäπ': 0,
            'ÌïòÎùΩ': 0,
            'Ìö°Î≥¥': 0
        };

        for (const [name, data] of Object.entries(timeFrameTrends)) {
            weightedTrends[data.trend] += data.weight;
        }

        // Ïù¥Ï†Ñ Ï∂îÏÑ∏ÏôÄ ÎπÑÍµê
        if (previousWeightedTrends) {
            // Î™®Îì† Ï†êÏàòÍ∞Ä ÎèôÏùºÌïúÏßÄ ÌôïÏù∏
            const isAllScoresEqual = previousWeightedTrends['ÏÉÅÏäπ'] === weightedTrends['ÏÉÅÏäπ'] && 
                                   previousWeightedTrends['ÌïòÎùΩ'] === weightedTrends['ÌïòÎùΩ'] && 
                                   previousWeightedTrends['Ìö°Î≥¥'] === weightedTrends['Ìö°Î≥¥'];
            
            if (isAllScoresEqual) {
                console.log('Î™®Îì† Ï∂îÏÑ∏ Ï†êÏàòÍ∞Ä ÎèôÏùºÌïòÏó¨ Î©îÏãúÏßÄÎ•º Î≥¥ÎÇ¥ÏßÄ ÏïäÏäµÎãàÎã§.');
                previousWeightedTrends = weightedTrends;
                return;
            }
        }
        
        // Í∞ÄÏû• ÎÜíÏùÄ Ï†êÏàò Ï∞æÍ∏∞
        const maxWeightedScore = Math.max(weightedTrends['ÏÉÅÏäπ'], weightedTrends['ÌïòÎùΩ'], weightedTrends['Ìö°Î≥¥']);
        const dominantTrend = Object.entries(weightedTrends)
            .find(([_, score]) => score === maxWeightedScore)[0];
        
        // ÌòÑÏû¨ ÏòàÏ∏° Ï†ïÎ≥¥ Ï†ÄÏû•
        currentPrediction = {
            timestamp: new Date(),
            predictedTrend: dominantTrend,
            price: currentPrice
        };

        // Ï∂îÏÑ∏Ïóê Îî∞Î•∏ Ïù¥Î™®ÏßÄ ÏÑ†ÌÉù
        let overallEmoji = '';
        if (dominantTrend === 'ÏÉÅÏäπ') overallEmoji = 'üìà';
        else if (dominantTrend === 'ÌïòÎùΩ') overallEmoji = 'üìâ';
        else overallEmoji = '‚öñÔ∏è';

        message += `\n*Ï¢ÖÌï© Ï∂îÏÑ∏ Î∂ÑÏÑù ${overallEmoji}*\n`;

        // Í∞Å Ï†êÏàò Ï∂úÎ†• (Í∞ÄÏû• ÎÜíÏùÄ Ï†êÏàòÎäî Ï∂îÍ∞Ä Í∞ïÏ°∞)
        Object.entries(weightedTrends).forEach(([trend, score]) => {
            const emoji = trend === 'ÏÉÅÏäπ' ? 'üìà' : trend === 'ÌïòÎùΩ' ? 'üìâ' : '‚öñÔ∏è';
            const scoreText = score === maxWeightedScore ? `${score}Ï†ê‚≠êÔ∏è` : `${score}Ï†ê`;
            message += `${emoji} ${trend}: *${scoreText}*\n`;
        });

        console.log(`ÌÖîÎ†àÍ∑∏Îû®ÏúºÎ°ú ÏïåÎ¶º Ï†ÑÏÜ°: ${message}`);
        await bot.sendMessage(process.env.TELEGRAM_CHAT_ID, message, { parse_mode: 'Markdown' });

        // ÌòÑÏû¨ Ï∂îÏÑ∏ Ï†êÏàòÎ•º Ïù¥Ï†Ñ Ï∂îÏÑ∏ Ï†êÏàòÎ°ú Ï†ÄÏû•
        previousWeightedTrends = weightedTrends;

    } catch (error) {
        console.error('ÏóêÎü¨ Î∞úÏÉù:', error.message);
    }
}

// ÌîÑÎ°úÍ∑∏Îû® ÏÉÅÌÉú Ï∂úÎ†• Ìï®Ïàò
function printStatus() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('ko-KR', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
    console.log(`[${timeString}] ÌîÑÎ°úÍ∑∏Îû® ÎèôÏûëÏ§ë... ${SYMBOL} Î™®ÎãàÌÑ∞ÎßÅ Ï§ë`);
}

// 5Ï¥àÎßàÎã§ ÏÉÅÌÉú Ï∂úÎ†•
setInterval(printStatus, 30000);

// Ï¥àÍ∏∞ Ïã§Ìñâ
console.log(`${SYMBOL} Î™®ÎãàÌÑ∞ÎßÅ ÌîÑÎ°úÍ∑∏Îû® ÏãúÏûë`);
checkPriceAndNotify();

const priceCheckInterval = 60000 * 5; // 5Î∂Ñ
const accuracyCheckInterval = 60000 * 30; // 30Î∂Ñ

// 5Î∂ÑÎßàÎã§ Í∞ÄÍ≤©ÏùÑ ÌôïÏù∏
setInterval(checkPriceAndNotify, priceCheckInterval);

// 30Î∂ÑÎßàÎã§ ÏòàÏ∏° Ï†ïÌôïÎèÑ Î∂ÑÏÑù Ïã§Ìñâ
setInterval(analyzePredictionAccuracy, accuracyCheckInterval);
